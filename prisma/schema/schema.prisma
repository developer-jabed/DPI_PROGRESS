generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===================== ENUMS =====================
enum Role {
  ADMIN
  TEACHER
  CR
  STUDENT
}

enum AttendanceStatus {
  DRAFT        // Not yet submitted
  PRESENT
  ABSENT
  VACATION     // Sick or other reasons
}  

enum Shift {
  MORNING
  DAY
}

enum GroupName {
  A
  B
}

enum AttendanceStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
  CORRECTED
}

enum SessionStatus {
  SCHEDULED
  CANCELLED
  COMPLETED
}

// ===================== USERS =====================
model User {
  id          String   @id @default(uuid())
  email       String?  @unique
  password    String
  displayName String?
  role        Role
  profileUrl  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  student          Student?           @relation("UserStudent")
  teacher          Teacher?           @relation("UserTeacher")
  cr               Cr?                @relation("UserCr")
  admin            Admin?             @relation("UserAdmin")
  notices          Notice[]           @relation("NoticePostedBy")
  attendanceMarked AttendanceRecord[] @relation("MarkedBy")
  attendanceAudits AttendanceAudit[]  @relation("ChangedBy")
}

// ===================== ADMIN =====================
model Admin {
  id          String   @id @default(uuid())
  user        User     @relation("UserAdmin", fields: [userId], references: [id])
  userId      String   @unique
  profileUrl  String?
  phoneNumber String?
  designation String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// ===================== DEPARTMENTS =====================
model Department {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())

  subjects   Subject[]       @relation("DepartmentSubjects")
  teachers   Teacher[]
  batches    Batch[]         @relation("DepartmentBatches")
  classrooms Classroom[]
  schedules  ScheduleEntry[] @relation("DepartmentSchedules")
  notices    Notice[]        @relation("DepartmentNotices")
}

// ===================== SUBJECTS =====================
model Subject {
  id       String @id @default(uuid())
  code     String
  title    String
  semester Int

  // Many-to-many relation with Department
  departments Department[] @relation("DepartmentSubjects")

  // Many-to-many relation with Teacher
  teachers Teacher[] @relation("TeacherSubjects")

  schedules ScheduleEntry[]
}

// ===================== TEACHERS =====================
model Teacher {
  id           String     @id @default(uuid())
  user         User       @relation("UserTeacher", fields: [userId], references: [id])
  userId       String     @unique
  department   Department @relation(fields: [departmentId], references: [id])
  departmentId String
  maxLoad      Int        @default(20)
  phoneNumber  String?
  bio          String?
  profileUrl   String?

  subjects       Subject[]             @relation("TeacherSubjects")
  availabilities TeacherAvailability[]
  leaves         TeacherLeave[]
  assignments    ScheduleEntry[]
  extraMarks     ExtraMark[]
  penalties      Penalty[]
}

// ===================== TEACHER AVAILABILITY & LEAVES =====================
model TeacherAvailability {
  id        String  @id @default(uuid())
  teacher   Teacher @relation(fields: [teacherId], references: [id])
  teacherId String
  dayOfWeek Int
  slotIndex Int
}

model TeacherLeave {
  id        String   @id @default(uuid())
  teacher   Teacher  @relation(fields: [teacherId], references: [id])
  teacherId String
  startDate DateTime
  endDate   DateTime
  reason    String?
}

// ===================== BATCHES & STUDENTS =====================
model Batch {
  id           String                 @id @default(uuid())
  year         Int
  semester     Int
  shift        Shift
  groupName    GroupName
  department   Department?            @relation("DepartmentBatches", fields: [departmentId], references: [id])
  departmentId String?
  students     Student[]
  schedules    BatchOnScheduleEntry[] @relation("BatchScheduleEntries")
  cr           Cr?                    @relation("BatchCr")
  notices      Notice[]               @relation("BatchNotices")
}

model Student {
  id                 String             @id @default(uuid())
  user               User               @relation("UserStudent", fields: [userId], references: [id])
  userId             String             @unique
  rollNumber         String             @unique
  registrationNumber String             @unique
  phoneNumber        String
  parentsPhone       String
  batch              Batch              @relation(fields: [batchId], references: [id])
  batchId            String
  attendances        AttendanceRecord[]
  extraMarks         ExtraMark[]
  penalties          Penalty[]
  firstLogin         Boolean            @default(true)

  // Correct relation name and backreference to Cr
  cr Cr? @relation("StudentCr")
}

model Cr {
  id        String  @id @default(uuid())
  // A CR is a specific user (who must also be a student)
  user      User    @relation("UserCr", fields: [userId], references: [id])
  userId    String  @unique
  student   Student @relation("StudentCr", fields: [studentId], references: [id])
  studentId String  @unique
  batch     Batch   @relation("BatchCr", fields: [batchId], references: [id])
  batchId   String  @unique
}

// ===================== CLASSROOM =====================
model Classroom {
  id           String          @id @default(uuid())
  name         String          @unique
  department   Department?     @relation(fields: [departmentId], references: [id])
  departmentId String?
  capacity     Int
  schedules    ScheduleEntry[]
}

// ===================== SCHEDULE & CLASS SESSIONS =====================
model ScheduleEntry {
  id           String                 @id @default(uuid())
  department   Department             @relation("DepartmentSchedules", fields: [departmentId], references: [id])
  departmentId String
  subject      Subject                @relation(fields: [subjectId], references: [id])
  subjectId    String
  teacher      Teacher?               @relation(fields: [teacherId], references: [id])
  teacherId    String?
  dayOfWeek    Int
  slotIndex    Int
  shift        Shift
  groupName    GroupName
  classroom    Classroom?             @relation(fields: [classroomId], references: [id])
  classroomId  String?
  isPractical  Boolean                @default(false)
  sessions     ClassSession[]
  // Many-to-many with batches
  batches      BatchOnScheduleEntry[]
}

// Many-to-many pivot table
model BatchOnScheduleEntry {
  id              String        @id @default(uuid())
  batch           Batch         @relation("BatchScheduleEntries", fields: [batchId], references: [id])
  batchId         String
  scheduleEntry   ScheduleEntry @relation(fields: [scheduleEntryId], references: [id])
  scheduleEntryId String
}

// ===================== CLASS SESSIONS =====================
model ClassSession {
  id              String             @id @default(uuid())
  scheduleEntry   ScheduleEntry?     @relation(fields: [scheduleEntryId], references: [id])
  scheduleEntryId String?
  date            DateTime
  status          SessionStatus      @default(SCHEDULED)
  attendance      AttendanceRecord[]
  createdAt       DateTime           @default(now())
}

// ===================== ATTENDANCE =====================
model AttendanceRecord {
  id         String            @id @default(uuid())
  session    ClassSession      @relation(fields: [sessionId], references: [id])
  sessionId  String
  student    Student           @relation(fields: [studentId], references: [id])
  studentId  String
  present    Boolean
  markedBy   User              @relation("MarkedBy", fields: [markedById], references: [id])
  markedById String
  status     AttendanceStatus  @default(DRAFT)
  reason     String?
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  audits     AttendanceAudit[]
}

model AttendanceAudit {
  id            String           @id @default(uuid())
  attendance    AttendanceRecord @relation(fields: [attendanceId], references: [id])
  attendanceId  String
  changedBy     User             @relation("ChangedBy", fields: [changedById], references: [id])
  changedById   String
  changeType    String
  previousValue String?
  newValue      String?
  reason        String?
  createdAt     DateTime         @default(now())
}

// ===================== EXTRA MARKS & PENALTIES =====================
model ExtraMark {
  id        String   @id @default(uuid())
  student   Student  @relation(fields: [studentId], references: [id])
  studentId String
  givenBy   Teacher  @relation(fields: [teacherId], references: [id])
  teacherId String
  points    Float
  reason    String?
  createdAt DateTime @default(now())
}

model Penalty {
  id        String   @id @default(uuid())
  student   Student  @relation(fields: [studentId], references: [id])
  studentId String
  givenBy   Teacher  @relation(fields: [teacherId], references: [id])
  teacherId String
  points    Float
  reason    String?
  createdAt DateTime @default(now())
}

// ===================== NOTICES =====================
model Notice {
  id           String      @id @default(uuid())
  title        String
  body         String
  postedBy     User        @relation("NoticePostedBy", fields: [postedById], references: [id])
  postedById   String
  department   Department? @relation("DepartmentNotices", fields: [departmentId], references: [id])
  departmentId String?
  batch        Batch?      @relation("BatchNotices", fields: [batchId], references: [id])
  batchId      String?
  shift        Shift?
  groupName    GroupName?
  targetRole   Role?
  isPublic     Boolean     @default(false)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
}
